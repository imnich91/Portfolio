'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _Field = require('./Field');

var _Field2 = _interopRequireDefault(_Field);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A Fieldset creates a set of fields that act as a single entity
 * A Form itself is a Fieldset and can consist of multiple fieldset.
 * A Fieldset acts as a input element and provides value to the form.
 */

var Fieldset = function (_React$Component) {
  _inherits(Fieldset, _React$Component);

  function Fieldset(props, context) {
    _classCallCheck(this, Fieldset);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Fieldset).call(this, props, context));

    _this.state = {
      inputs: {}
    };
    return _this;
  }

  _createClass(Fieldset, [{
    key: 'getChildContext',
    value: function getChildContext() {
      return {
        fieldset: this
      };
    }
  }, {
    key: 'registerInput',
    value: function registerInput(name, component) {
      var isArray = name.endsWith("[]");
      name = isArray ? name.substr(0, name.length - 2) : name;

      var inp = this.state.inputs[name];

      // if the input has not been defined, define the input
      if (inp === undefined) {
        this.state.inputs[name] = isArray ? [component] : component;
        return;
      }

      if (!isArray) {
        // Only array types are allowed to have more than one registration
        console.error("Cannot register more than one input with the same name '" + name + "'. Are you trying to register an array of input in which case use a name ending with [].");
        return;
      }

      if (!inp instanceof Array) {
        // Looks like the user has mixed up the same name with and without array def
        console.error("Looks like you have mixed up the name '" + name + "' with and without array suffix ([]) on multiple components.");
        return;
      }

      inp.push(component);
    }
  }, {
    key: 'unregisterInput',
    value: function unregisterInput(name, component) {
      var isArray = name.endsWith("[]");
      name = isArray ? name.substr(0, name.length - 2) : name;

      var inp = this.state.inputs[name];
      if (inp === undefined) {
        console.error("Trying to unregister a component named '" + name + "' which was not registered. Should be a bug.");
        return;
      }

      if (inp instanceof Array) {
        var idx = inp.indexOf(component);
        if (idx === -1) {
          console.error("Trying to unregister one of the component named '" + name + "' but was not found in the list. Should be a bug.");
          return;
        } else {
          inp.splice(idx, 1);
          if (inp.length === 0) {
            delete this.state.inputs[name];
          }
        }
      } else {
        if (component !== inp) {
          console.warn("Trying to unregister the component with name '" + name + "' but something else was registered on that name. Should be a bug.");
          return;
        } else {
          delete this.state.inputs[name];
        }
      }
    }
  }, {
    key: 'getDefaultValue',
    value: function getDefaultValue(name) {
      var isArray = name.endsWith("[]");
      name = isArray ? name.substr(0, name.length - 2) : name;
      return this.props.value && this.props.value[name];
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.context.fieldset.registerInput(this.props.name, this);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.context.fieldset.unregisterInput(this.props.name, this);
    }
  }, {
    key: 'getFirstInput',
    value: function getFirstInput() {
      for (var name in this.state.inputs) {
        var inp = this.state.inputs[name];
        if (inp instanceof Array) {
          return inp[0];
        } else {
          return inp;
        }
      }
      return null;
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      var _this2 = this;

      // retrieve the value provided by this set, the value is initialized
      // with the values provided overridden by the suppressing values and
      // finally by the input provided by the user
      var value = Object.assign({}, this.props.value, this.props.suppress);
      var inputs = Object.keys(this.state.inputs);
      var count = inputs.length;

      return new Promise(function (resolve, reject) {
        inputs.forEach(function (name) {
          var inp = _this2.state.inputs[name];
          var p = inp instanceof Array ? Promise.all(inp.map(function (i) {
            return i.getValue();
          })) : inp.getValue();
          p.then(function (v) {
            value[name] = v;
            count -= 1;
            if (count === 0) {
              resolve(value);
            }
          });
        });
      });
    }
  }, {
    key: 'validate',
    value: function validate(value) {
      var _this3 = this;

      var res = {};
      return new Promise(function (resolve) {
        var inputs = Object.keys(_this3.state.inputs);
        var count = inputs.length;
        inputs.forEach(function (name) {
          var inp = _this3.state.inputs[name];
          var promise = inp instanceof Array ? Promise.all(inp.map(function (i) {
            return i.validate(value[name]);
          })) : inp.validate(value[name]);
          promise.then(function (v) {
            res[name] = v;
            count -= 1;
            if (count === 0) {
              resolve(res);
            }
          });
        });
      });
    }
  }, {
    key: 'generate',
    value: function generate(attributes, suppress, value) {
      return attributes.map(function (attr) {
        if (suppress && suppress.hasOwnProperty(attr.name)) {
          return false;
        }

        // handle the array type fields
        var isArray = attr.name.endsWith("[]");
        var name = isArray ? attr.name.substr(0, attr.name.length - 2) : attr.name;
        var defaultValue = value && value[name];

        if (isArray && defaultValue instanceof Array) {
          var fields = [];
          for (var i = 0; i <= defaultValue.length; ++i) {
            fields.push(_react2.default.createElement(_Field2.default, _extends({ key: name + "." + i }, attr, { value: defaultValue[i] })));
          }
          return fields;
        } else {
          return _react2.default.createElement(_Field2.default, _extends({ key: name }, attr, { value: defaultValue }));
        }

        //return <Field key={attr.name} {...attr} value={value[attr.name]}/>
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props;
      var className = _props.className;
      var children = _props.children;
      var value = _props.value;
      var attributes = _props.attributes;
      var suppress = _props.suppress;

      var other = _objectWithoutProperties(_props, ['className', 'children', 'value', 'attributes', 'suppress']);

      var autoChildren = attributes ? this.generate(attributes, suppress, value) : false;

      return _react2.default.createElement(
        'div',
        _extends({ className: className }, other),
        children,
        autoChildren
      );
    }
  }]);

  return Fieldset;
}(_react2.default.Component);

Fieldset.contextTypes = {
  fieldset: _react2.default.PropTypes.object
};

Fieldset.childContextTypes = {
  fieldset: _react2.default.PropTypes.object
};

Fieldset.propTypes = {
  name: _react2.default.PropTypes.string.isRequired,
  value: _react2.default.PropTypes.object,
  attributes: _react2.default.PropTypes.arrayOf(_react2.default.PropTypes.object),
  suppress: _react2.default.PropTypes.object
};

exports.default = Fieldset;